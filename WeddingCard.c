/*
 * WeddingCard.c
 *
 * Created: 11/13/2012 8:11:05 PM
 *  Author: Bill&Mara
 *
 *	For project details see: http://www.billporter.info/?p=1655
 *
 *		Theory for sleep and light sensing inspired by:
 *			http://spritesmods.com/?art=minimalism&page=4	
 *				Though there were some bugs in the code and it didn't follow AVR Clib instructions
 *				for safe sleep; so I mostly rewrote the code to correct. 

 *
 */ 




#define F_CPU 1200000UL  // 1.2 MHz Though really it is less than this. timings will be off; not important

#include <util/delay.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <avr/sleep.h>
#include <avr/wdt.h>

//LED names match schematic. Backwards, I know. 
#define LED1 PB4 //ADC 2
#define LED2 PB3 //ADC 3
#define LED3 PB1 
#define LED4 PB0
#define SENSOR PB2 //ADC 1




//these ASM macros configure the WatchDog timer for interrupt only mode without touching the reset bit. 
//using the AVRClib macros (which touch the reset bit) was causing unexpected behavior. 
//pulled from http://www.avrfreaks.net/index.php?name=PNphpBB2&file=printview&t=51070&start=0
//It also means we don't need to keep touching the WDT interrupt bit.

#define wdt_set(value)   \
    __asm__ __volatile__ (  \
        "in __tmp_reg__,__SREG__" "\n\t"    \
        "cli" "\n\t"    \
        "wdr" "\n\t"    \
        "sts %0,%1" "\n\t"  \
        "out __SREG__,__tmp_reg__" "\n\t"   \
        "sts %0,%2" \
        : /* no outputs */  \
        : "M" (_SFR_MEM_ADDR(_WD_CONTROL_REG)), \
        "r" (_BV(_WD_CHANGE_BIT) | _BV(WDE)), \
            "r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) | \
                _BV(WDTIE) | (value & 0x07)) ) \
        : "r0"  \
    ) 


#define wdt_off(x)   \
    __asm__ __volatile__ (  \
        "in __tmp_reg__,__SREG__" "\n\t"    \
        "cli" "\n\t"    \
        "wdr" "\n\t"    \
        "sts %0,%1" "\n\t"  \
        "sts %0,%2" \
        : /* no outputs */  \
        : "M" (_SFR_MEM_ADDR(_WD_CONTROL_REG)), \
        "r" (_BV(_WD_CHANGE_BIT) | _BV(WDE)), \
            "r" ((uint8_t) (0x00)) \
        : "r0"  \
    ) 

#define SETLOW(pin) (PORTB&=~(1<<pin))
#define ALLLEDS (1<<LED1)|(1<<LED2)|(1<<LED3)|(1<<LED4)

uint8_t incrementFrame(uint8_t);
void lightShow(void);
uint16_t getLight(void);
void easterEgg(void);
void powerOffUc(void);

//sparkle effect PWM values generated by Vixen Light Show software
static PROGMEM prog_uint8_t vixen_show_data[] = {0,0,0,178,163,148,133,118,103,88,73,58,43,0,0,0,0,0,178,163,148,178,178,163,148,133,118,178,163,178,163,148,133,118,103,178,178,163,148,133,118,178,163,148,178,178,163,148,133,178,163,148,133,118,178,163,148,178,163,178,178,163,148,133,178,178,163,148,178,163,148,133,178,163,148,133,178,178,163,148,133,178,163,148,178,163,178,163,148,133,118,103,178,163,148,178,178,163,148,178,163,148,133,118,103,178,163,148,178,178,163,148,133,118,103,88,73,58,43,178,163,148,133,118,103,88,73,58,43,0,0,0,0,0,0,0,0,0,0,0,0,0,178,163,178,163,148,133,178,178,163,148,133,118,103,88,178,163,148,133,118,103,178,163,148,133,118,103,88,73,58,43,0,0,178,163,178,163,148,133,118,103,88,73,58,178,163,148,133,118,103,88,73,58,43,0,178,127,76,0};

//easter egg storage
static PROGMEM prog_uint8_t easteregg[]={"-... .. .-.. .-.. / .- -. -.. / -- .- .-. .- / --. . . -.- ... / - --- --. . - .... . .-. / ..-. --- .-. . ...- . .-. .-.-.-"};
	
uint8_t frame1, frame2, frame3, frame4; //index for each LED channel
uint8_t match1, match2, match3, match4; //match compare for Software PWM
uint8_t triggercount;

uint16_t threshold;

int main(void)
{
	
	//set IO Direction
	DDRB = ALLLEDS;	
	
	//flash all LEDs on/off
	PORTB = ALLLEDS;
	_delay_ms(200);
	PORTB = 0;
	_delay_ms(1000);
	
	//From here on in the micro will always be powered. So we'll capture ambient light first and store it as the threshold. 
	//this means shorting reset will re-cal this threshold
	threshold = getLight();
	//egthreshold = getLight(ALED2);
	
	//flash all LEDs on/off
	PORTB = ALLLEDS;
	_delay_ms(200);
	PORTB = 0;
	//_delay_ms(1000);
	
	
	//lets go ahead and get ready for bed
	set_sleep_mode(SLEEP_MODE_PWR_DOWN);
	
	//main 'loop'
	while(1){
		//see if we should go to sleep or start the show
		if(getLight()<threshold) 						
			lightShow();
		else
			powerOffUc();
			

	}
	
    
}	

uint16_t getLight(void) {
    
	uint16_t val;
    
	
	//select correct ADC pin and voltage reference
	ADMUX=(1<<REFS0)|(1<<MUX0);
    ADCSRA=0x83;//enable adc, max prescaler
	
	//turn on pullup
	PORTB = (1<<SENSOR);
	
	//read ADC
    ADCSRA|=0x40; //go do adc
    while(ADCSRA&0x40) ; //wait till adc is done
    val=ADC;
	
	//disable adc
    ADCSRA=0; 
	
	//turn off pullup
    PORTB = 0;
	
    return val;
}


void lightShow(void){
	
	//make sure they are set to output
    DDRB = ALLLEDS;
	
	//load index starts
	frame1=0;
	frame2=50;
	frame3=100;
	frame4=150;
	
	for(uint8_t z=0; z<=200; z++)//run the show for 20 seconds. 
		{
			//Software PWM for the 4 channels. 
		
			//load match compares from program memory. Doing this once each time saves cycles.
			match1 = pgm_read_byte(&(vixen_show_data[frame1]));
			match2 = pgm_read_byte(&(vixen_show_data[frame2]));
			match3 = pgm_read_byte(&(vixen_show_data[frame3]));
			match4 = pgm_read_byte(&(vixen_show_data[frame4]));
		
			//freerun PWM for so many times and set pin low on compare
			for(uint8_t y=0; y<18; y++){ //each y is a PWM period. run so many PWM periods. See clock math below
				
				//set all pins HIGH
				PORTB = ALLLEDS;
				
				for(uint8_t i=0; i<255; i++){ //each i is a PWM division where compares should be made
					if(match1 == i) SETLOW(LED1); //each of these lines take 4 clocks 
					if(match2 == i) SETLOW(LED2);
					if(match3 == i) SETLOW(LED3);
					if(match4 == i) SETLOW(LED4); //so I used 16 clocks to compare all channels. 
					
					//16 clocks per PWM division x 255 divisions = 4080 clocks per PWM period
					//at 1.2Mhz that's a PWM freq of ~300 Hz. Good enough, no need to delay
					//Since Light show is 10Hz, each PWM period should be repeated 30 times. 
					// But with 3V the RC oscillator runs slower than predicted. Changed to 
					// 18 times through experimentation. 
				}
				
			
			}
		
		//move frame index's up
		frame1 = incrementFrame(frame1);
		frame2 = incrementFrame(frame2);
		frame3 = incrementFrame(frame3);
		frame4 = incrementFrame(frame4);
	}
	
		//after show, run easter egg if led is in dark
	if(getLight()>threshold) 
		easterEgg();
}

//quick function to move indexs up by one and wrap around
uint8_t incrementFrame(uint8_t framez) {
	
	framez++;
	if (framez > 199) framez = 0;
	
	return framez;
}

void easterEgg(){
	
	//make sure they are set to output
    //DDRB = 0b00011110;
	
	#define timeunit 180
	
	_delay_ms(timeunit*7);
	
	char temp = 0;
	
	for(int i=0; i<sizeof(easteregg); i++){
		
		temp = pgm_read_byte(&(easteregg[i]));
		
		if (temp == '.') {
			//set all pins HIGH
			PORTB = ALLLEDS;
			_delay_ms(timeunit);
			PORTB = 0;
			_delay_ms(timeunit);
		}
		else if (temp == '-') {
			//set all pins HIGH
			PORTB = ALLLEDS;
			_delay_ms(timeunit*3);
			PORTB = 0;
			_delay_ms(timeunit);
		}
		else if (temp == ' ') {
			//interletter delay, 3 dots
			_delay_ms(timeunit*3);
		}
		else //interword delay, 7 dots
			_delay_ms(timeunit*7);
		
	}
	
}

ISR(WDT_vect) {
		//empty interrupt routine 

}

//Configure the uC for power saving and enter sleep
//As written this function will return when the Watchdog alarm goes off.
//but won't reset the uC so RAM is safe. 
void powerOffUc(void) {
    
	//set IO for power save
	PORTB=0; DDRB=0;
	//get ready for bed
	sleep_enable();
	//need interrupts running for WDT alarm to work
	sei();
	//set wakeup for 2 seconds from now
	wdt_set(WDTO_2S);
	//go to sleep
	sleep_cpu();
	//wake up from sleep
	sleep_disable();  
	//turn off alarm
	wdt_off(); 
	//I don't use interrupts anyway. Leave em off. 
	cli();
}



